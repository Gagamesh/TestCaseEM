"""
Класс, который реализует программу-справочник,
в котором указаны: Фамилия, Имя, Отчество, Название организации,
Телефон рабочий,Телефон сотовый.
В программе реализованы: постраничный вывод записей(одна страница == 10 записей),
добавление новой записи, редактирование записи, поиск записи по ключевому слову.
К файлу .py прилогается фалйл .csv, который является справочником, и с которым ведется работа.
"""
import csv
import sys
from pathlib import PurePosixPath


class TelephoneDirectory:
    """
    Сам класс, методы которого реализуют возможности справочника.
    """

    def __init__(self, file):
        """
        Метод, в котором находятся переменные экземпляра класса.
        """
        self.data = []  # Переменная, в которую я отправляю обработанные данные, с которыми можно будет работать.
        self.file = file  # Файл-справочник, который указывается при создании экземпляра класса

    def reader(self):
        """
        Метод, который читает данные с файла, обрабатывает базовые ошибки связанные с данными,
        канвертирует данные в формат, с которым можно работать.
        """
        if PurePosixPath(self.file).suffix == '.csv':  # Проверка что файл .csv
            try:
                with open(self.file) as csv_file:  # Менеджеры контекста with...as удобнее для работы с файлами
                    reader = csv.DictReader(csv_file)  # Переменная для чтения .csv как dict
                    self.data = [line for line in reader]  # Заполняем данными из файла переменную из init
                    if not self.data:  # Дальше идут обработки ошибок
                        raise NameError("Файл пуст")
            except FileNotFoundError:
                raise FileNotFoundError('Файл не найден')
        else:
            raise NameError('Необходим файл формата .csv')

    def pagereader(self, index):
        """
        Метод, реализующий возможность постраничного просмотра справочника.
        Аргумент index будет раскрыт в методе __call__, необходим для отсечения страниц.
        """
        return '\n'.join([' '.join(list(x.values())) for x in self.data[index:index + 10]])

    def adder(self):
        """
        Метод, позволяющий добавить новую строку в справочнике.
        """
        update_data = [input('Фамилия:'), input('Имя:'), input('Отчество:'), input('Название организации:'),
                       input('Телефон рабочий:'), input('Телефон сотовый:')]  # Получаем новые данные от пользователя
        for parameter in update_data:  # Проверка были ли введены данные
            if not parameter:
                print('Данные не были введены')
        with open(self.file, 'a') as f_update:
            file_writer = csv.writer(f_update, delimiter=',', lineterminator='\r')
            file_writer.writerow(update_data)  # Запись новой строки

    def updater(self):
        """
        Метод, дающий возможность изменять данные справочника.
        """
        obj = input("Поиск изменяемой строки\nВведите данные любого столбца необходимой строки:")  # Запрос строки
        column = input('Введите столбец для замены:')  # Запрос замены
        if not obj or not column:  # Если данные не ввели
            print('Данные не были введены')
        for row in self.data:  # Проходим по строкам данных
            if obj in ' '.join(list(row.values())):  # Проверяем наличие запроса пользователя в справочнике
                print(row)  # В случае совпадений, по каким либо параметрам, возможно будет выбрать необходимую строку
                answer = input("Это необходимая строка? да/нет:")  # Пользователь отвечает та ли эта строка
                if answer == "да":
                    row[column] = input("Новое значение:")  # Когда строка выбрана вводится новый параметр
        question = input(
            'Желаете изменить что-то ещё?\n1:да\n2:нет\n')  # При желании пользователь может менять по несколько строк, не завершая сеанс
        if question == "да" or question == '1':
            self.updater()  # Запускает этот же метод рекурсией
        else:  # Либо при окончании изменений в строках записывает данные в справочник
            with open(self.file, 'w') as csv_file:
                fieldnames = ['Фамилия', 'Имя', 'Отчество', 'Название организации',
                              'Телефон рабочий', 'Телефон сотовый']
                writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
                writer.writeheader()
                for row in self.data:
                    writer.writerow(row)

    def finder(self):
        """
        Метод, позволяет искать в справочнике необходимые строки
        """
        res = []  # Результаты поиска
        obj = input('Введите одно или несколько значений для поиска:')  # Пользователь вводит слова для поиска
        if not obj:  # Если данные не ввели
            print('Данные не были введены')
        for row in self.data:
            for word in obj.split():
                if word in ' '.join(list(row.values())):  # Поиск соответствия заданного параметра в справочнике
                    res.append(" ".join(list(row.values())))  # Добавляет совпадение в список результата
        if not res:  # Если совпадений нет
            print('Данные не были найдены')
        else:  # если есть выводим результат
            return "\n".join(set(res))

    def __call__(self, *args, **kwargs):
        """
        Метод перегрузки, реализующий вызов экземпляра класса как функцию.
        В данном методе я постарался сделать простенький "стартовый экран",
        с которого можно начинать работу со справочником, и когда будут реализованы
        все запланированные действия, с помощью этого "стартового экрана" можно выйти из программы.
        """
        self.reader()  # Запуск метода чтения файла
        print('Введите номер опции\n1:Чтение\n2:Добавление\n3:Обновление\n4:Поиск\n5:Выход')  # Простенький интерфейс
        command = input("Команда:")  # Выбор опции
        if not command:  # В слуае неверного выбора вас вернет на выбор опции
            self.__call__()
        elif command not in ['1', '2', '3', '4', '5']:
            self.__call__()
        if command == '1':  # Тут я реализую постраничный вывод данных справочника
            page = 1  # Номер страницы, который будет увеличиваться
            index = 0  # Индекс, который пойдет в аргумент функции и будет служить срезом страницы, будет увеличиваться
            print(f'Страница {str(page)}\n' + self.pagereader(index))  # Постраничный вывод на экран данных
            while True:  # Цикл для просмотра страниц
                nxt = input(
                    'Продолжить? да/нет:')  # Вопрос пользователю для перехода на следующую страницу
                if nxt == 'да':  # если да то номер страницы увеличивается на 1 а индекс на 10
                    page += 1
                    index += 10
                    print(f'Страница {str(page)}\n' + self.pagereader(index))  # выводится новая страница
                else:  # Для выхода на главную страницу
                    self.__call__()
        elif command == '2':  # запускает метод добавления строки, после чего выводит на главную страницу
            self.adder()
            self.__call__()
        elif command == '3':  # запускает метод обновления данных строки, после чего выводит на главную страницу
            self.updater()
            self.__call__()
        elif command == '4':  # запускает метод поиска данных, после чего выводит на главную страницу
            print(self.finder())
            self.__call__()
        elif command == '5':  # Выход из программы
            sys.exit()


ft = TelephoneDirectory('phones.csv')  # Экземпляр класса
ft()  # Вызов перехватится методом __call__
